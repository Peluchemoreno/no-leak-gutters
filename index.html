<!DOCTYPE html>
<html lang="en" id="whole">
  <head>
    <!-- do not change or delete this file, it is for making the password page -->
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      content="width=device-width"
      initial-scale="1.0"
      maximum-scale="1.0"
      user-scalable="0"
      name="viewport"
    />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="img/icons8-inspection-40.png" type="image/x-icon" />
    <title>Bid Maker</title>
    <!-- <link rel="stylesheet" href="styles.css" /> -->
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 14px;
      }

      body {
        position: relative;
      }

      .modal {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.6);
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease, visiblity 0.2s ease;
      }

      .modal_visible {
        display: flex;
        position: absolute;
        background-color: rgba(0, 0, 0, 0.6);
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        justify-content: center;
        align-items: center;
        visibility: visible;
        opacity: 1;
        transition: opacity 0.2s ease, visiblity 0.2s ease;
      }

      .modal__container {
        padding: 20px;
        border: 1px solid black;
        background-color: #414141;
        color: white;
        max-width: 50%;
      }

      .container__input {
        width: 100%;
        margin-top: 20px;
        color: black;
        padding: 5px;
      }

      .container__buttons {
        display: flex;
        justify-content: flex-end;
        gap: 20px;
        margin-top: 20px;
      }

      .container__title {
        font-size: 1.25rem;
      }

      .button {
        padding: 5px 15px;
        border: none;
        cursor: pointer;
      }

      .button_confirm {
        background-color: #26e600;
      }

      .button_cancel {
        background-color: rgb(240, 90, 90);
      }

      .header-description-phrase {
        color: #ffb221;
        font-weight: bold;
        letter-spacing: 1px;
        font-size: 17px;
      }

      .header-description {
        max-width: 400px;
        text-align: center;
      }

      .header-description-information {
        font-weight: bold;
        font-family: "Times New Roman", Times, serif;
        margin-top: 10px;
        font-size: 15px;
      }

      .submision-container {
        border: 1px solid black;
        padding: 10px;
        display: flex;
        flex-direction: column;
        width: 100%;
        padding: 10px;
        margin-top: 5px;
      }

      .info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 5px;
        margin-top: -20px;
        width: 800px;
      }

      .info-section-split {
        display: flex;
        flex-grow: 1;
        gap: 5px;
      }

      input {
        border: none;
        border-bottom: 1px solid black;
      }

      label {
        margin-top: 5px;
        font-size: 12px;
      }

      .label-job {
        margin: 0;
        font-size: 12px;
        display: flex;
        place-items: center;
        /* border: 1px solid red; */
        width: 40px;
      }

      label input {
        width: 80%;
      }

      .state input,
      .zip input {
        width: 100px;
      }

      .info-bid-by {
        display: flex;
        align-items: flex-end;
      }

      .option {
        margin-left: 10px;
      }

      .complteted-by-input {
        /* border: 1px solid red; */
        width: 73%;
      }

      .other-input {
        width: 87%;
      }

      .header-description {
        margin-top: -50px;
      }

      .info-section-split_gutter-style {
        display: flex;
        align-items: center;
      }

      .info-section-split_gutter-input {
        width: 15%;
        text-align: center;
      }

      .input-container {
        /* border: 1px solid red; */
        display: flex;
        align-items: center;
      }

      .gutter-container,
      .soffit-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
      }

      .gutter-container_cell,
      .soffit-container_cell {
        display: flex;
        /* border: 1px solid red; */
      }

      .gutter-container_input {
        width: 30%;
        text-align: center;
      }

      .soffit-container_input {
        text-align: center;
        width: 20%;
      }

      .soffit-container_input2 {
        text-align: center;
        width: 10%;
      }

      .soffit-container_cell_long {
        grid-column: 1 / 3;
        margin-bottom: 22px;
      }

      .details__header {
        font-weight: bold;
        margin-left: 5px;
      }

      .details__header-text {
        display: inline-block;
        font-weight: bold;
        font-family: "Times New Roman", Times, serif;
      }

      .details__body {
        display: flex;
      }

      .body__text {
        font-size: 10px;
        line-height: 1.3;
        /* border: 1px solid red; */
        padding: 5px;
        width: 75%;
        margin: 0;
      }

      .body__form {
        font-size: 10px;
        border: 1px solid black;
        padding: 10px;
        width: 35%;
        display: flex;
        flex-direction: column;
      }

      .input_checkbox {
        width: 10px;
        margin-right: 5px;
      }

      .body__form-text {
        font-size: 10px;
        display: inline-block;
        margin: 0;
      }

      .form__label {
        display: flex;
        align-items: center;
      }

      .form__label:nth-of-type(3) {
        /* background-color: red; */
        margin-bottom: 5px;
      }

      .form__label_long {
        margin-top: 0;
      }

      .body__form-text_other {
        margin-right: 5px;
      }

      .body__form-text_other1 {
        width: 15%;
        text-align: center;
      }

      .form__label_sig {
        flex-grow: 1;
        font-size: 10px;
      }

      .form__label_date {
        font-size: 10px;
      }

      .signature-section {
        display: flex;
        justify-content: space-between;
        /* border: 1px solid black; */
        position: absolute;
        bottom: -10px;
        padding: 5px;
        width: 60%;
      }

      .form__label_date {
        margin-left: 10px;
      }

      .sig__line {
        margin-left: 10px;
      }

      .details {
        position: relative;
      }

      .footer {
        margin-top: 15px;
        border: 1px solid black;
        padding: 5px;
        display: grid;
        grid-template-columns: 4fr 1fr;
      }

      .form__input {
        width: 40%;
      }

      .body__form-text_other1 {
        text-align: center;
      }

      .cancel-button,
      .set-button {
        border: none;
        border-radius: 5px;
        padding: 10px;
        font-size: 14px;
        background-color: transparent;
        font-weight: bold;
      }

      .cancel-button:hover,
      .set-button:hover {
        cursor: pointer;
        background-color: rgba(0, 0, 0, 0.6);
      }

      .selector-button {
        padding: 10px;
        border: none;
        border-bottom: 2px solid black;
        border-radius: 5px;
      }

      .selector-button:last-of-type {
        border-bottom: 2px solid rgb(126, 126, 126);
      }

      .selector-button:hover {
        cursor: pointer;
      }

      .color-preview {
        height: 25px;
        width: 25px;
        background-color: black;
        border-radius: 50%;
        border: 2px solid black;
        transition: background-color 0.5s;
        transition: border 0.5s;
      }

      .red {
        background-color: red;
      }

      .cyan {
        background-color: cyan;
      }

      .blue {
        background-color: blue;
      }

      .green {
        background-color: #2efc05;
      }

      .pink {
        background-color: magenta;
      }

      .yellow {
        background-color: yellow;
      }

      .black {
        background-color: #000;
        color: #fff;
      }

      #canvas {
        background-size: cover;
        border: 1px solid black;
        width: 800px;
        height: 400px;
        margin-top: 5px;
      }

      .header-logo {
        width: 350px;
        margin-top: -40px;
        margin-left: -25px;
      }

      .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        /* height: 140px; */
      }

      .date-container {
        align-self: flex-end;
        padding: 20px;
      }

      .customer-details-header {
        color: rgb(255, 255, 255);
        background-color: black;
        margin: 0;
        padding: 10px;
        letter-spacing: 3px;
        border: 2px solid black;
      }

      .customer-details-body {
        display: grid;
        grid-template-columns: 1fr 7fr 1fr 7fr;
        margin-bottom: 0;
        /* border: 1px solid green; */
      }

      .customer-details-body2 {
        display: grid;
        grid-template-columns: 1fr 7fr;
        /* border: 1px solid red; */
        margin-top: 0px !important;
      }

      #email {
        flex-grow: 1;
        text-align: left;
      }

      select {
        text-align: right;
        border: none;
      }

      .form-wrapper {
        margin: 0 auto;
        max-width: 820px;
        /* border: 1px solid blue; */
        /* height: 100svh; */
      }

      .section2 {
        display: flex;
        max-width: 820px;
        /* border: 1px solid red; */
        /* height: 400px; */
      }

      .material-side {
        border-bottom: 2px solid black;
        border-right: 2px solid black;
      }

      .material-side {
        flex-grow: 1;
      }

      .material-details-header,
      .extra-and-pricing-header,
      .job-notes-header {
        text-align: center;
        padding: 5px;
        background-color: black;
        color: white;
        letter-spacing: 3px;
      }

      .job-notes {
        background-color: black;
        display: block;
        letter-spacing: 3px;
        margin-top: 5px;
      }

      #job-notes {
        width: 100%;
        padding: 5px;
        font-size: 11px;
        resize: none;
        border-right: none;
        border-bottom: none;
        border-left: 1px solid black;
      }

      .material-details-body,
      .extra-and-pricing-body {
        display: grid;
        grid-template-columns: 1fr 2fr;
      }

      form {
        padding: 10px;
        width: 100%;
      }

      .tools-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0;
        max-width: 500px;
      }

      .tools-bar button,
      .tools-bar input,
      .tools-bar select {
        border-radius: 5px;
        padding: 5px 10px;
        background-color: silver;
        flex-grow: 1;
        margin: auto 3px;
        max-height: 30px;
        font-size: 12px;
        font-weight: 600;
      }

      .tools-bar select {
        font-weight: 400;
      }

      #clear-button {
        background-color: rgb(241, 112, 112);
      }

      #tool-select {
        text-align: left;
        background-color: silver;
        border: none;
        border-radius: 5px;
        width: 70px;
      }

      #finish-button {
        background: rgb(94, 235, 94);
      }

      #grid-size {
        max-width: 70px;
      }

      @media print {
        body {
          print-color-adjust: exact;
          -webkit-print-color-adjust: exact;
        }
      }

      #additions,
      #additions2,
      #additions3,
      #screen {
        resize: none;
        padding: 1px;
        text-align: right;
        overflow: hidden;
        font-size: 10px;
        scroll-behavior: none;
      }

      #color {
        text-align: center;
        padding: 0;
        height: 25px;
      }
    </style>
  </head>

  <body>
    <div class="modal">
      <div class="modal__container">
        <h2 class="container__title">
          Type in the elbow sequence or the length of the piece. (ex: AABA, 57")
        </h2>
        <input id="textinput" type="text" class="container__input" />
        <div class="container__buttons">
          <button type="button" class="button button_cancel">Cancel</button>
          <button type="button" class="button button_confirm">OK</button>
        </div>
      </div>
    </div>
    <div class="form-wrapper">
      <form>
        <div class="header-container">
          <img class="header-logo" src="./img/no-leak-logo.png" alt="logo" />
          <div class="header-description">
            <h2 class="header-description-phrase">
              TREATING YOUR HOME LIKE OUR OWN
            </h2>
            <p class="header-description-information">
              (941) 800-7311 | www.noleakgutters.com | noleakgutters@gmail.com
            </p>
          </div>
        </div>
        <section class="info">
          <div class="info-section">
            <h2 class="proposal-submision">PROPOSAL SUBMITTED TO:</h2>
            <div class="proposal-submision-info submision-container">
              <label for="name">
                Name:
                <input type="text" id="name" />
              </label>
              <label for="address">
                Address:
                <input type="text" id="address" />
              </label>
              <div class="info-section-split">
                <label class="info-section-split" for="city">
                  City:
                  <input type="text" id="city" />
                </label>
                <label class="info-section-split state" for="state">
                  State:
                  <input type="text" id="state" />
                </label>
              </div>
              <div class="info-section-split">
                <label class="info-section-split" for="phone">
                  Phone:
                  <input type="text" id="phone" />
                </label>
                <label class="info-section-split zip" for="zip">
                  Zip:
                  <input type="text" id="zip" />
                </label>
              </div>
            </div>
          </div>
          <div class="info-section">
            <h2 class="proposal-submision">PROPOSAL/CONTRACT:</h2>
            <div class="proposal-submision-info submision-container">
              <div class="info-section-split">
                <label class="info-section-split date-label" for="name">
                  Date:
                  <input type="date" id="name" />
                </label>
                <label class="info-section-split" for="jobNumber">
                  <p class="label-job">Job #:</p>
                  <input type="text" />
                </label>
              </div>
              <div class="info-bid-by">
                <label for="bid-by"> Bid By: </label>
                <div class="option">
                  <input type="checkbox" name="bid-by" id="phone" />
                  Phone
                </div>
                <div class="option">
                  <input type="checkbox" name="bid-by" id="blueprint" />
                  Blue Print
                </div>
                <div class="option">
                  <input type="checkbox" name="bid-by" id="fieldmeasure" />
                  Field Measure:
                </div>
              </div>
              <label for="other">
                Other:
                <input class="other-input" type="text" />
              </label>
              <label class="completed-by-label" for="completedby">
                Completed By:
                <input class="complteted-by-input" type="text" />
              </label>
            </div>
          </div>
          <div class="info-section">
            <h2 class="proposal-submision">GUTTER:</h2>
            <div class="proposal-submision-info submision-container">
              <div class="gutter-container">
                <div class="gutter-container_cell">
                  <label for="gutter">
                    6" 'K' Style
                    <input type="text" class="gutter-container_input" />
                    ft
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="wedges">
                    <input type="text" class="gutter-container_input" />
                    Wedges
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="miter-corners">
                    <input type="text" class="gutter-container_input" />
                    Outside Miter Corners
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="strip-miter-corners">
                    <input type="text" class="gutter-container_input" />
                    Inside Miter Corners
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="downspouts">
                    <input type="text" class="gutter-container_input" />
                    Downspouts
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="splash-guards">
                    <input type="text" class="gutter-container_input" />
                    Splash Guards
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="lg-downspouts">
                    <input type="text" class="gutter-container_input" />
                    Large Downspout
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="deinstallation">
                    <input type="text" class="gutter-container_input" />
                    De-installation
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="outlet">
                    <input type="text" class="gutter-container_input" />
                    Outlet
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="gutter">
                    <input type="text" class="gutter-container_input" />
                    Gutter
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="custom-corner">
                    <input type="text" class="gutter-container_input" />
                    Custom Corner
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="leaf-guards">
                    <input type="text" class="gutter-container_input" />
                    Leaf Guards
                  </label>
                </div>
                <div class="gutter-container_cell">
                  <label for="caps">
                    <input type="text" class="gutter-container_input" />
                    Caps
                  </label>
                </div>
              </div>
              <div class="gutter-container">
                <label for="other"
                  >Other:
                  <input type="text" />
                </label>
                <label for="color"
                  >Color:
                  <input type="text" />
                </label>
              </div>
            </div>
          </div>
          <div class="info-section">
            <h2 class="proposal-submision">SOFFIT:</h2>
            <div class="proposal-submision-info submision-container">
              <div class="soffit-container">
                <div class="soffit-container_cell">
                  <label for="overhang">
                    Overhang
                    <input type="text" class="soffit-container_input" />
                    "
                    <input type="text" class="soffit-container_input" />
                    ft
                  </label>
                </div>
                <div></div>
                <div class="soffit-container_cell">
                  <label for="corners">
                    <input type="text" class="gutter-container_input" />
                    Corners
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="deinstallation">
                    <input type="text" class="gutter-container_input" />
                    De-installation
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="cut-out">
                    <input type="text" class="gutter-container_input" />
                    Cut-Out
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="wood-install">
                    <input type="text" class="gutter-container_input" />
                    Wood Install
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="box end">
                    <input type="text" class="gutter-container_input" />
                    Box End
                  </label>
                </div>
                <div></div>
                <div class="soffit-container_cell">
                  <label for="cut-out">
                    <input type="text" class="soffit-container_input" />
                    Fascia w/o soffit
                    <input type="text" class="soffit-container_input" />
                    ft
                  </label>
                </div>
                <div></div>
                <div class="soffit-container_cell soffit-container_cell_long">
                  <label for="additional-overhang">
                    Additional Overhang
                    <input type="text" class="soffit-container_input2" />
                    "
                    <input type="text" class="soffit-container_input2" />
                    ft
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="cut-out">
                    Other:
                    <input type="text" />
                  </label>
                </div>
                <div class="soffit-container_cell">
                  <label for="cut-out">
                    Color:
                    <input type="text" />
                  </label>
                </div>
              </div>
            </div>
          </div>
        </section>

        <div class="section2">
          <div class="canvas-side">
            <canvas id="canvas"></canvas>
            <div class="tools-bar">
              <select id="tool-select">
                <option value="gutter">Gutter</option>
                <!-- <option value="gutter-w-screen">Gutter w/ Screen</option> -->
                <option value="existing-gutter">Existing Gutter</option>
                <option value="downspout">Downspout</option>
                <option value="drop">Drop to lower</option>
                <option value="valley-shield">Valley Shield</option>
                <option value="free-text">Elbow Seq/Piece Length</option>
                <option value="eraser">Eraser</option>
              </select>
              <input
                type="number"
                min="10"
                max="50"
                id="grid-size"
                value="14"
              />
              <!-- <button id="color">Color</button> -->
              <select id="color">
                <option
                  value="black"
                  style="background-color: black; color: white"
                >
                  Black
                </option>
                <option value="red" style="background-color: red; color: white">
                  Red
                </option>
                <option
                  value="cyan"
                  style="background-color: cyan; color: black"
                >
                  Cyan
                </option>
                <option
                  value="blue"
                  style="background-color: blue; color: white"
                >
                  Blue
                </option>
                <option
                  value="green"
                  style="background-color: #2efc05; color: black"
                >
                  Green
                </option>
                <option
                  value="magenta"
                  style="background-color: magenta; color: black"
                >
                  Magenta
                </option>
                <option value="yellow" style="background-color: yellow">
                  Yellow
                </option>
              </select>
              <button type="button" class="undo-button">Undo</button>
              <button type="button" id="clear-button">Clear</button>
              <!-- <button type="button" id="show-legend" onclick="showLegend()">LGND</button> -->
              <button type="button" id="finish-button" onclick="finish()">
                Done
              </button>
            </div>
            <div class="details">
              <div class="details__header">
                <span>x</span>
                <p class="details__header-text">
                  Indicates position of downspout.
                </p>
              </div>
              <div class="details__body">
                <div class="body__text">
                  If there are any alterations or deviations from the above
                  specified proposal involving extra cost that cost will become
                  an additional charge above the original proposal price. All
                  agreements contingent upon strikes, accidents or delays that
                  are beyond our control. Owner to carry fire, tornado, theft
                  and any other necessary insurance upon above work. Should this
                  contract be terminated for any reason during the work as
                  specified above - the owner agrees to pay in full for all of
                  the labor and materials furnished up to the date of such
                  termination at the rate and price specified. This schematic is
                  not a final result, it is what may have been spoken
                  through/recommended by and to expected to be installed, please
                  do not hesitate to contact us to make any changes, changes
                  must be made in writing and confirmed by No Leak Gutters
                  through email or text.
                </div>
                <div class="body__form">
                  <p class="body__form-text">Payment to be made as follows:</p>
                  <label for="paid-in-full" class="form__label">
                    <input type="checkbox" class="input_checkbox" />
                    <p class="body__form-text">Paid in full upon completion</p>
                  </label>
                  <label for="other" class="form__label">
                    <input type="checkbox" class="input_checkbox" />
                    <p class="body__form-text body__form-text_other">Other:</p>
                    <input type="text" />
                  </label>
                  <label for="submitted-by" class="form__label">
                    <p class="body__form-text">Submitted By:</p>
                    <input type="text" class="body__form-text_other" />
                  </label>
                  <label
                    for="price-of-proposal"
                    class="form__label form__label_long"
                  >
                    <p class="body__form-text">
                      Price of proposal may change after
                    </p>
                  </label>
                  <label for="form__label" class="form__label form__label_long"
                    ><input
                      type="text"
                      class="body__form-text_other body__form-text_other1"
                    />
                    <p class="body__form-text">days if not accepted</p></label
                  >
                </div>
              </div>
              <div class="signature-section">
                <label for="sig" class="form__label form__label_sig"
                  >Authorized Signature:
                  <input type="text" class="sig__line" />
                </label>
                <label for="date" class="form__label form__label_date">
                  Date:
                  <input type="date" name="date" id="date" />
                </label>
              </div>
            </div>
            <div class="footer">
              <label for="add-notes"
                >Additional Notes:
                <input type="text" />
              </label>
              <label for="total"
                >Total proposal $:
                <input type="text" class="form__input" />
              </label>
            </div>
          </div>
        </div>
      </form>
    </div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <!-- <script src="scripts.js"></script> -->
    <script>
      // const canvas = document.getElementById("canvas");
      // const ctx = canvas.getContext("2d");
      // const undoBtn = document.querySelector(".undo-button");
      // const clearButton = document.querySelector("#clear-button");
      // const colorPicker = document.querySelector("#color");
      // const gridSizeInput = document.querySelector("#grid-size");
      // const tool = document.querySelector("#tool-select");
      // const textInputEl = document.querySelector(".container__input");
      // const cancelBtn = document.querySelector(".button_cancel");
      // const confirmBtn = document.querySelector(".button_confirm");
      // const modal = document.querySelector(".modal");

      // let isDrawing = false;
      // let startX, startY, currentX, currentY;
      // let paths = [];
      // let index = -1;
      // let rubberLinePath = null;

      // // Initialize Canvas
      // function startup() {
      //   canvas.width = 500;
      //   canvas.height = 500;
      //   drawGrid();
      //   updateUndoButton();
      // }

      // // Draw the grid on the canvas
      // function drawGrid() {
      //   const gridSize = parseInt(gridSizeInput.value);
      //   ctx.clearRect(0, 0, canvas.width, canvas.height);
      //   ctx.strokeStyle = "lightgray";
      //   for (let x = 0; x < canvas.width; x += gridSize) {
      //     ctx.beginPath();
      //     ctx.moveTo(x, 0);
      //     ctx.lineTo(x, canvas.height);
      //     ctx.stroke();
      //   }
      //   for (let y = 0; y < canvas.height; y += gridSize) {
      //     ctx.beginPath();
      //     ctx.moveTo(0, y);
      //     ctx.lineTo(canvas.width, y);
      //     ctx.stroke();
      //   }
      // }

      // // Snap coordinates to the nearest grid point
      // function snapToGrid(value) {
      //   const gridSize = parseInt(gridSizeInput.value);
      //   return Math.round(value / gridSize) * gridSize;
      // }

      // // Get coordinates from event (supports both mouse and touch)
      // function getCoordinates(event) {
      //   const rect = canvas.getBoundingClientRect();
      //   const x = event.touches ? event.touches[0].clientX : event.clientX;
      //   const y = event.touches ? event.touches[0].clientY : event.clientY;
      //   return {
      //     x: snapToGrid(x - rect.left),
      //     y: snapToGrid(y - rect.top),
      //   };
      // }

      // // Update the color based on user selection
      // function updateColor() {
      //   ctx.strokeStyle = colorPicker.value;
      //   ctx.fillStyle = colorPicker.value;
      // }

      // function addToUndoStack() {
      //   paths.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      //   index++;
      //   updateUndoButton();
      // }

      // // Start drawing
      // function startDrawing(event) {
      //   isDrawing = true;
      //   const { x, y } = getCoordinates(event);
      //   startX = x;
      //   startY = y;
      //   updateColor();
      //   if (tool.value === "gutter") {
      //     ctx.setLineDash([]);
      //   } else if (tool.value === "existing-gutter") {
      //     ctx.setLineDash([2, 2]);
      //   } else if (tool.value === "downspout" || tool.value === "drop") {
      //     ctx.setLineDash([]);
      //   }
      // }

      // // Draw a rubber line
      // function drawRubberLine(event) {
      //   if (
      //     !isDrawing ||
      //     tool.value === "downspout" ||
      //     tool.value === "drop" ||
      //     tool.value === "valley-shield" ||
      //     tool.value === "free-text"
      //   )
      //     return;
      //   const { x, y } = getCoordinates(event);
      //   currentX = x;
      //   currentY = y;

      //   if (rubberLinePath) {
      //     ctx.putImageData(rubberLinePath, 0, 0); // Clear temporary line
      //   } else {
      //     rubberLinePath = ctx.getImageData(0, 0, canvas.width, canvas.height);
      //   }

      //   ctx.beginPath();
      //   ctx.moveTo(startX, startY);
      //   ctx.lineTo(currentX, currentY);
      //   ctx.lineWidth = 2;
      //   ctx.stroke();
      // }

      // // Finalize the line on pointer up
      // function stopDrawing() {
      //   if (isDrawing) {
      //     isDrawing = false;
      //     rubberLinePath = null; // Clear rubber band

      //     if (tool.value === "downspout") {
      //       ctx.beginPath();
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX + gridSizeInput.value / 2.75,
      //         startY + gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX - gridSizeInput.value / 2.75,
      //         startY + gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX - gridSizeInput.value / 2.75,
      //         startY - gridSizeInput.value / 2.75
      //       );
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(
      //         startX + gridSizeInput.value / 2.75,
      //         startY - gridSizeInput.value / 2.75
      //       );
      //       ctx.stroke();
      //       addToUndoStack();
      //     } else if (tool.value === "drop") {
      //       ctx.beginPath();
      //       ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      //       ctx.stroke();
      //       addToUndoStack();
      //     } else if (tool.value === "valley-shield") {
      //       ctx.beginPath();
      //       ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      //       ctx.fill();
      //       addToUndoStack();
      //     } else if (tool.value === "free-text") {
      //       modal.classList.add("modal_visible");
      //       // let userInput = prompt(
      //       //   'Type in the elbow sequence or the length of the piece. (ex: AABA, 57")'
      //       // );
      //     } else {
      //       ctx.beginPath();
      //       ctx.moveTo(startX, startY);
      //       ctx.lineTo(currentX, currentY);
      //       ctx.lineWidth = 2;
      //       ctx.stroke();

      //       // Save the path state
      //       addToUndoStack();
      //     }
      //   }
      // }

      // // Undo the last action
      // undoBtn.addEventListener("click", () => {
      //   undo();
      // });

      // function undo() {
      //   if (index <= 0) {
      //     clearCanvas();
      //   } else {
      //     index--;
      //     paths.pop();
      //     ctx.putImageData(
      //       paths[index] || ctx.getImageData(0, 0, canvas.width, canvas.height),
      //       0,
      //       0
      //     );
      //     updateUndoButton();
      //   }
      // }

      // // Clear the canvas
      // function clearCanvas() {
      //   ctx.clearRect(0, 0, canvas.width, canvas.height);
      //   drawGrid();
      //   paths = [];
      //   index = -1;
      //   updateUndoButton();
      // }

      // clearButton.addEventListener("click", clearCanvas);

      // // Update the undo button
      // function updateUndoButton() {
      //   undoBtn.innerText = paths.length > 0 ? "Undo" : "Update Grid";
      //   undoBtn.style.backgroundColor = paths.length > 0 ? "silver" : "#d9f170";
      // }

      // function placeText(x, y) {
      //   const userInput = textInputEl.value;
      //   ctx.font = "1000 12px Arial";
      //   ctx.fillStyle = "black";
      //   ctx.textAlign = "center";
      //   if (!userInput) {
      //     return;
      //   } else {
      //     ctx.fillText(`${userInput}`, x, y);
      //     addToUndoStack();
      //   }
      //   textInputEl.value = "";
      //   modal.classList.remove("modal_visible");
      // }

      // // Add event listeners
      // canvas.addEventListener("pointerdown", startDrawing);
      // canvas.addEventListener("pointermove", drawRubberLine);
      // canvas.addEventListener("pointerup", stopDrawing);
      // canvas.addEventListener("pointerout", stopDrawing);

      // cancelBtn.addEventListener("click", (e) => {
      //   modal.classList.remove("modal_visible");
      //   textInputEl.value = "";
      // });

      // confirmBtn.addEventListener("click", (e) => {
      //   placeText(startX, startY);
      // });

      // // Add touch events for mobile and tablets
      // canvas.addEventListener("touchstart", (event) => {
      //   event.preventDefault();
      //   startDrawing(event);
      // });
      // canvas.addEventListener("touchmove", (event) => {
      //   event.preventDefault();
      //   drawRubberLine(event);
      // });
      // canvas.addEventListener("touchend", (event) => {
      //   event.preventDefault();
      //   stopDrawing();
      // });
      // canvas.addEventListener("touchcancel", stopDrawing);

      // // Initialize on DOMContentLoaded
      // document.addEventListener("DOMContentLoaded", startup);
      // document.addEventListener("keydown", (e) => {
      //   if (e.key === "Escape") {
      //     undo();
      //   }
      // });

      // function finish() {
      //   window.onbeforeprint = (event) => {
      //     toolsBar = document.querySelector(".tools-bar");
      //     toolsBar.style.display = "none";
      //     legendPic = document.querySelector(".legend-pic");
      //   };
      //   window.print();
      // }

      // window.onafterprint = (event) => {
      //   toolsBar = document.querySelector(".tools-bar");
      //   toolsBar.style.display = "flex";
      // };

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const undoBtn = document.querySelector(".undo-button");
      const clearButton = document.querySelector("#clear-button");
      const colorPicker = document.querySelector("#color");
      const gridSizeInput = document.querySelector("#grid-size");
      const tool = document.querySelector("#tool-select");
      const textInputEl = document.querySelector(".container__input");
      const cancelBtn = document.querySelector(".button_cancel");
      const confirmBtn = document.querySelector(".button_confirm");
      const modal = document.querySelector(".modal");

      let isDrawing = false;
      let startX, startY, currentX, currentY;
      let lines = []; // Store start and end coordinates for lines
      let index = -1;
      let rubberLinePath = null;
      let history = []; // History to store previous states of the canvas

      // Initialize Canvas
      function startup() {
        canvas.width = 800;
        canvas.height = 400;
        drawGrid();
        updateUndoButton();
      }

      // Draw the grid on the canvas
      function drawGrid() {
        ctx.setLineDash([]);
        const gridSize = parseInt(gridSizeInput.value);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "lightgray";
        for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      // Snap coordinates to the nearest grid point
      function snapToGrid(value) {
        const gridSize = parseInt(gridSizeInput.value);
        return Math.round(value / gridSize) * gridSize;
      }

      // Get coordinates from event (supports both mouse and touch)
      function getCoordinates(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.touches ? event.touches[0].clientX : event.clientX;
        const y = event.touches ? event.touches[0].clientY : event.clientY;
        return {
          x: snapToGrid(x - rect.left),
          y: snapToGrid(y - rect.top),
        };
      }

      // Update the color based on user selection
      function updateColor() {
        ctx.strokeStyle = colorPicker.value;
        ctx.fillStyle = colorPicker.value;
      }

      // Start drawing
      function startDrawing(event) {
        isDrawing = true;
        const { x, y } = getCoordinates(event);
        startX = x;
        startY = y;
        ctx.lineWidth = 2;
        updateColor();

        if (tool.value === "gutter") {
          ctx.setLineDash([]);
        } else if (tool.value === "existing-gutter") {
          ctx.setLineDash([2, 2]);
        } else if (tool.value === "downspout" || tool.value === "drop") {
          ctx.setLineDash([]);
        }

        if (tool.value === "eraser") {
          // Additional eraser logic if needed
          return;
        }
      }

      // Draw a rubber line (for both drawing and erasing)
      function drawRubberLine(event) {
        if (
          !isDrawing ||
          tool.value === "downspout" ||
          tool.value === "free-text" ||
          tool.value === "drop" ||
          tool.value === "valley-shield" ||
          tool.value === "eraser"
        )
          return;

        const { x, y } = getCoordinates(event);
        currentX = x;
        currentY = y;

        if (rubberLinePath) {
          ctx.putImageData(rubberLinePath, 0, 0); // Clear temporary line
        } else {
          rubberLinePath = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(currentX, currentY);
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Finalize the line on pointer up
      function stopDrawing(event) {
        if (isDrawing) {
          isDrawing = false;
          rubberLinePath = null; // Clear rubber band

          if (tool.value === "downspout") {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX + gridSizeInput.value / 2.75,
              startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX - gridSizeInput.value / 2.75,
              startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX - gridSizeInput.value / 2.75,
              startY - gridSizeInput.value / 2.75
            );
            ctx.moveTo(startX, startY);
            ctx.lineTo(
              startX + gridSizeInput.value / 2.75,
              startY - gridSizeInput.value / 2.75
            );
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "drop") {
            ctx.beginPath();
            ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "valley-shield") {
            ctx.beginPath();
            ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
            ctx.fill();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: startX,
              endY: startY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          } else if (tool.value === "free-text") {
            modal.classList.add("modal_visible");
          } else if (tool.value === "eraser") {
            console.log(startX, startY);
            eraseNearestLine(); // Call the erase function to remove entire lines
          } else {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(currentX, currentY);
            ctx.lineWidth = 2;
            ctx.stroke();
            // Add line coordinates instead of ImageData
            lines.push({
              startX,
              startY,
              endX: currentX,
              endY: currentY,
              tool: tool.value,
              color: colorPicker.value,
            });
            updateUndoButton();
          }
          if (tool.value !== "free-text") {
            saveState();
          }
        }
      }

      function placeText(x, y) {
        const userInput = textInputEl.value;
        ctx.font = "1000 12px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        if (!userInput) {
          return;
        } else {
          ctx.fillText(`${userInput}`, x, y);
          // addToUndoStack();
          lines.push({
            startX,
            startY,
            endX: startX,
            endY: startY,
            tool: tool.value,
            content: userInput,
            color: colorPicker.value,
          });
          saveState();
        }
        textInputEl.value = "";
        modal.classList.remove("modal_visible");
      }

      function eraseNearestLine() {
        const tolerance = 10; // Tolerance in pixels for erasing (you can adjust this)

        // Loop through the stored lines and check if they intersect with the eraser area
        for (let i = lines.length - 1; i >= 0; i--) {
          let line = lines[i];

          // Check if the line is within the eraser's tolerance
          if (
            isLineCloseToCursor(
              line.startX,
              line.startY,
              line.endX,
              line.endY,
              startX,
              startY,
              tolerance
            )
          ) {
            lines.splice(i, 1); // Remove the line from lines
            redrawCanvas(); // Redraw canvas with updated lines
            break;
          }
          if (
            line.tool === "downspout" ||
            line.tool === "drop" ||
            line.tool === "valley-shield" ||
            line.tool === "free-text"
          ) {
            if (
              distanceBetweenPoints(line.startX, line.startY, startX, startY) <
              10
            ) {
              lines.splice(i, 1); // Remove the line from lines
              redrawCanvas(); // Redraw canvas with updated lines
              break;
            }
          }
        }
        updateUndoButton(); // Keep track of the undo stack after erasing a line
      }

      // Function to check if a line intersects with the eraser's area
      // function lineIntersects(x1, y1, x2, y2, line, tolerance) {
      //   const dx = x2 - x1;
      //   const dy = y2 - y1;
      //   const dist =
      //     Math.abs(dy * line.startX - dx * line.startY + x2 * y1 - y2 * x1) /
      //     Math.sqrt(dx * dx + dy * dy);
      //   return dist <= tolerance;
      // }

      // Function to calculate the distance from a point to a line
      // Function to check if a line intersects with the eraser's area
      function isLineCloseToCursor(x1, y1, x2, y2, mouseX, mouseY, radius) {
        // Calculate the perpendicular distance from the mouse to the line
        const distance = pointToLineDistance(x1, y1, x2, y2, mouseX, mouseY);

        // Check if the distance is within the given radius
        return distance <= radius;
      }

      // Function to calculate the perpendicular distance from a point to a line
      function pointToLineDistance(x1, y1, x2, y2, px, py) {
        // Calculate the distance using the point-to-line distance formula
        const numerator = Math.abs(
          (y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1
        );
        const denominator = Math.sqrt(
          Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)
        );
        return numerator / denominator;
      }

      function distanceBetweenPoints(x1, y1, x2, y2) {
        const dx = x2 - x1; // Difference in x coordinates
        const dy = y2 - y1; // Difference in y coordinates

        // Apply the distance formula
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Redraw the entire canvas based on stored lines
      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setLineDash([]);
        drawGrid();
        updateColor();
        lines.forEach((line) => {
          console.log(line.color);
          ctx.strokeStyle = line.color;
          ctx.fillStyle = line.color;
          if (line.tool === "downspout") {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX + gridSizeInput.value / 2.75,
              line.startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX - gridSizeInput.value / 2.75,
              line.startY + gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX - gridSizeInput.value / 2.75,
              line.startY - gridSizeInput.value / 2.75
            );
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(
              line.startX + gridSizeInput.value / 2.75,
              line.startY - gridSizeInput.value / 2.75
            );
            ctx.setLineDash([]);
            ctx.stroke();
          } else if (line.tool === "drop") {
            ctx.beginPath();
            ctx.arc(
              line.startX,
              line.startY,
              gridSizeInput.value / 4,
              0,
              2 * Math.PI
            );
            ctx.setLineDash([]);
            ctx.stroke();
          } else if (line.tool === "valley-shield") {
            ctx.beginPath();
            ctx.arc(
              line.startX,
              line.startY,
              gridSizeInput.value / 4,
              0,
              2 * Math.PI
            );
            ctx.setLineDash([]);
            ctx.fill();
          } else if (line.tool === "existing-gutter") {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(line.endX, line.endY);
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.stroke();
          } else if (line.tool === "free-text") {
            ctx.font = "1000 12px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.fillText(line.content, line.startX, line.startY);
          } else {
            ctx.beginPath();
            ctx.moveTo(line.startX, line.startY);
            ctx.lineTo(line.endX, line.endY);
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.stroke();
          }
        });
      }

      // Undo the last action
      undoBtn.addEventListener("click", () => {
        undo();
      });

      function undo() {
        // debugger;
        if (history.length > 0) {
          // Pop the last saved state and restore the lines array
          history.pop();
          lines = history[history.length - 1];
          redrawCanvas(); // Redraw canvas with the previous state
          updateUndoButton(); // Update undo button state
        } else {
          clearCanvas(); // If no history, clear the canvas
        }
        updateUndoButton();
        console.log(lines, history);
      }

      function saveState() {
        history.push([...lines]); // Copy the current lines array to preserve the state
      }

      // Clear the canvas
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        lines = []; // Clear current lines
        history = []; // Clear history
        index = -1; // Reset the index (this is unnecessary)
        updateUndoButton(); // Update the undo button state
      }

      clearButton.addEventListener("click", clearCanvas);

      // Update the undo button
      function updateUndoButton() {
        if (lines && history) {
          undoBtn.innerText =
            lines.length > 0 && history.length > 0 ? "Undo" : "Update Grid";
          undoBtn.style.backgroundColor =
            lines.length > 0 && history.length > 0 ? "silver" : "#d9f170";
        } else {
          return;
        }
      }

      // Add event listeners
      canvas.addEventListener("pointerdown", startDrawing);
      canvas.addEventListener("pointermove", drawRubberLine);
      canvas.addEventListener("pointerup", () => {
        stopDrawing();
      });
      canvas.addEventListener("pointerout", stopDrawing);

      cancelBtn.addEventListener("click", () => {
        modal.classList.remove("modal_visible");
        textInputEl.value = "";
      });

      confirmBtn.addEventListener("click", () => {
        placeText(startX, startY);
        console.log(lines, history);
      });

      // Add touch events for mobile and tablets
      canvas.addEventListener("touchstart", (event) => {
        event.preventDefault();
        startDrawing(event);
      });
      canvas.addEventListener("touchmove", (event) => {
        event.preventDefault();
        drawRubberLine(event);
      });
      canvas.addEventListener("touchend", (event) => {
        event.preventDefault();
        stopDrawing();
      });
      canvas.addEventListener("touchcancel", stopDrawing);

      // Initialize on DOMContentLoaded
      document.addEventListener("DOMContentLoaded", startup);
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          undo();
        }
      });
    </script>
  </body>
</html>
